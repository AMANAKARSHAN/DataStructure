package Array;

import java.util.*;

public class ArrayApplication {
	Integer len;
	Integer arr[];
	
	public void insertElement(Integer arr[]) {
		this.arr=arr;
		len=arr.length;
	}
	
	public void printElement() {
		System.out.println();
		System.out.print("Array: ");
		for(int i=0;i<len;i++)
			System.out.print(arr[i]+" ");
	}
	
	
	//Find Largest Contiguous Sum Subarray 
	public int largestContiguousSubArrayNegative() {
		int max_so_far,curr_max;
		max_so_far = curr_max = 0;
		for(int i=0;i<len;i++) {
			curr_max=Math.max(arr[i],curr_max+arr[i]);
			max_so_far=Math.max(curr_max,max_so_far);
		}
		return max_so_far;
	}
	
	
	//Sort an array of 0s, 1s, 2s | Dutch National Flag Problem
	public void sortedArrayWith0s1s2sbest() {
		int low=0;
		int high=len-1;
		int mid=0;
		while(mid<high) {
			switch(arr[mid]) {
			case 0:
				if(arr[low]!=arr[mid]) {
					int t=arr[low];
					arr[low]=arr[mid];
					arr[mid]=t;
					}
				low++;
				mid++;
				break;
			case 1:
				mid++;
				break;
			case 2:
				if(arr[high]!=arr[mid]) {
					int t=arr[high];
					arr[high]=arr[mid];
					arr[mid]=t;
					}
				high--;
			}
		}
	}
	
	
	//Find Equilibrium point where elements before & after it has equal sum
	public int equilibriumPoint() {
		int sum=0,sum_so_far=0;
		for(int i=0;i<len;i++) {
			sum=sum+arr[i];
		}
		for(int j=0;j<len;j++) {
			sum=sum-arr[j];
			sum_so_far=sum_so_far+arr[j];
			if(sum==sum_so_far)
				return j+1;
		}
		
		return -1;
	}
	
	
	//Leaders in Array | Print Elements which are greater than all it's right elements
	public int leader(){
		int max=arr[len-1];
		for(int j=len-2;j>=0;j--) {
			if(arr[j]>max)
				max=arr[j];
		}
		return max;
	}
	
	
	//Find Missing Number from 1 to n range in Unsorted array
	public int missingNum() {
		int sum= len*(len-1)/2;
		for(int i=0;i<len;i++)
			sum=sum-arr[i];
		
		return sum;
	}
	
	
	//Search element using iterative binary Search 
	public int itebinarySearch(int val) {
		int l=0;
		int h=len-1,mid;
		while(l<=h) {
			mid=(l+h)/2;
			if(arr[mid]==val)
				return mid;
			else if(arr[mid]<val)
				l=mid+1;
			else
				h=mid-1;
		}
		
	return -1;	
	}
	
	
	//Search element using recursive binary Search	
	public int recbinarySearch(int val,int low,int high) {
		int mid=low+(low+high)/2;
		if(arr[mid]==val)
			return mid;
		else if(arr[mid]<val)
			return recbinarySearch(val,mid+1,high);
		else
			return recbinarySearch(val,low,mid-1);
	}
	
	
	//Check if there exists a pair which matches given Sum using Sorting
	public boolean pairExistOrNotAddition_sorting(int sum) {
		Arrays.sort(arr);
		int low=0;
		int high=len-1,val;
		val=arr[low]+arr[high];
		while(low<high) {
			val=arr[low]+arr[high];
			if(val==sum)
				return true;
			else if(val<sum) {
				low=low+1;
			}
			else {
				high=high-1;
			}
		}
		return false;
	}
	
	
	//Check if there exists a pair which matches given Sum using Hashing	
	public boolean pairExistOrNotAddition_hashing(int sum) {
		Set <Integer> st= new HashSet<Integer>();
		for(int i=0;i<len;i++) {
			if(st.contains(sum-arr[i]))
				return true;
			else
				st.add(arr[i]);
		}
		
		return false;
	}
	
	//Check if there exists a pair which matches given Multiplication using Hashing	
	//It can'nt be done by using Sorting
	public boolean pairExistOrNotMul_hashing(Float sum) {
		Set <Float> st= new HashSet<>();
		for(int i=0;i<len;i++) {
			if(st.contains(sum/arr[i].floatValue()))
				return true;
			else
				st.add(arr[i].floatValue());
		}
		
		return false;
	}
	
	
	//Find 1st occurrence of a value in array if adjacent values differ by 1
	public int findFirstOccurenceIfAdjencentValueDiffBy1(int val) {
		int start=0;
		
		while(start<len) {
			if(arr[start]==val)
				return start;
			
			int diff=Math.abs(arr[start]-val);
				start=start+diff;
		}
		return start;
	}
	

	 //Find 1st occurrence of a value if adjacent values differ by at most K
	public int findFirstOccurenceIfAdjencentValueDiffByAtMostk(int val,int k) {
		int start=0;
		
		while(start<len-1) {
			if(arr[start]==val)
				return start;
			
			int diff=Math.abs(arr[start]-val)/k;
				diff=Math.max(diff, 1);
				start=start+diff;
		}
		return start;
	}
	
	
	//Find the first repeating value in array
	public int firstRepeatingValueInArray() {
		int firstRepeat=-1;
		Set<Integer> st = new HashSet<>();
		
		for(int i=len-1;i>=0;i--) {
			if(st.contains(arr[i]))
				firstRepeat=arr[i];
			else
				st.add(arr[i]);
		}
		
		return firstRepeat;
	}
	
	
	
	public static void main(String[] args) {
		ArrayApplication ob = new ArrayApplication();
		Integer arr[]= {5,4,2,3,4};
		ob.insertElement(arr);
//		System.out.println("Largest Contiguous SubArray = " + ob.largestContiguousSubArrayNegative());
//		System.out.println("Equilibrium Point : "+ob.equilibriumPoint());
//		System.out.println("Binary Search Recursive : "+ob.recbinarySearch(4,0,6));
//		System.out.println("Binary Search Itirative : "+ob.itebinarySearch(4));
//		System.out.println("Leader in Array : "+ob.leader());
//	    System.out.println("Pair exist or Not for given add: "+ob.pairExistOrNotAddition_sorting(20));
//		System.out.println("Pair exist or Not for given add: "+ob.pairExistOrNotAddition_hashing(20));
//     	System.out.println("Find First Occurence If Adjencent Value Diff By 1 : "+ob.findFirstOccurenceIfAdjencentValueDiffBy1(0));
//		System.out.println("Find First Occurence If Adjencent Value Diff By 1 : "+ob.findFirstOccurenceIfAdjencentValueDiffByAtMostk(2));
//		System.out.println("First repeating value in array : "+ob.firstRepeatingValueInArray());
		System.out.println("Pair exist or Not for given Multiplication: "+ob.pairExistOrNotMul_hashing(7));
		
		} 
	}
